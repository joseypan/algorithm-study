// 动态规划：
//   动态规划是一种将复杂问题分解成更小的子问题来解决的优化技术
//   【注意】动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题
//   用动态规划解决问题时，要遵循三个重要步骤：
//   1、定义子问题
//   2、实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；
//   3、识别并求解出基线条件
//   能用动态规划解决的一些著名问题如下：
//     1、背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量
//     2、最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）
//     3、矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少），相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序
//     4、硬币找零：给出面额为d1,...dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法
//     5、图的全源最短路径：对所有顶点对（u,v），找出从顶点u到顶点v的最短路径。
//   最少硬币找零问题：
//     最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1...dn及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1,...,dn及其数量,找到所需的最少的硬币个数
//     例如：美国有以下面额（硬币）：d1 = 1,d2 = 5, d3 = 10, d4 = 25
//     如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（美分）
//     如何将这个解答转化成算法？
//     最少硬币找零的解决方案是找到n所需的最小硬币数。但要做到这一点，首先得找到对每个x<n的解。然后，我们可以基于更小的值的解来求解
function minCoinChange(coins, amount) {
  const cache = []; //使用cache来更高效且不重复计算值
  const makeChange = (value) => {
    if (!value) {
      return [];
    }
    if (cache[value]) {
      // 如果缓存中已经存在这个值了，不用再重复计算直接从缓存中获取
      return cache[value];
    }
    let min = [];
    let newWin;
    let newAmount;
    for (let i = 0; i < coins.length; i++) {
      const coin = coins[i];
      newAmount = value - coin;
      if (newAmount >= 0) {
        newWin = makeChange(newAmount);
      }
      if (
        newAmount >= 0 &&
        (newMin.length < min.length - 1 || !min.length) &&
        (newWin.length || !newAmount)
      ) {
        // 如果我们当前得到的这种组合方式所用的硬币数更少则将min进行替换
        min = [coin].concat(newWin);
      }
    }
    return cache[value] === min;
  };
  return makeChange(amount);
}
