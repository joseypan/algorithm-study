// 回溯算法
//   回溯算法建立在DFS基础之上的，但不同的是在搜索的过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索，因此我们可以这样子理解，回溯算法和DFS的区别就是有无状态重置
//   emm至于什么是DFS也不是很清楚
//   来源：
//     回溯算法也叫试探法，它是一种系统的搜索问题的解的方法
//     回溯算法解决问题的一般步骤：
//       1、针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解
//       2、确定易于搜索的解空间结构，使得能用回溯法方便地搜索整个解空间
//       3、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索
//     通俗来说：
//       回溯算法可以理解为通过选择不同的岔路口，来寻找目的地，一个岔路口一个岔路口的去尝试找到目的地，如果走错了路的话，继续返回到上一个岔路口的另外一条路，直到找到目的地
//   基本思路：
//     首先，我们得明确这个回溯算法的思路是什么？有了思路，才可以写出思路的伪代码，有了伪代码之后根据实际情况，写出相应的解决方案
//     决策树的一条路开始走，能进则进，不能进则退回来，换一条路试一试

//   八皇后问题：
//     十九世纪著名的数学家高斯在1850年提出：在8*8的国际象棋上摆放八个皇后（棋子），使其不能相互攻击，即任意两个皇后不能处于同一行，同一列或同一斜线上
// 八皇后问题的解空间
//   为了简化问题，将棋盘缩小为4
//   由于两个皇后不能处于同一行，所以每一行只能放一个皇后，可以放的位置是0,1,2,3。所以解空间就是从空棋盘开始，从上往下放上四个皇后
//   树的的第一层：
//     空棋盘
//     f(4,0,0,{}):棋盘大小是4，准备放皇后的行是0，也就是棋盘的第一行，当前防止了皇后的个数是0，{}空棋盘
//   树的第二层：
//     在第一行放置棋子，在第一行可以放置的棋子位置是0，1，2，3
//     f(4,0,0,{})：棋盘大小是4，准备放皇后的行是0，也就是棋盘的第一行，当前放置了皇后的个数是0，{}空棋盘
//     f(4,1,1,{i})：棋盘大小是4，准备放皇后的行是1，也就是棋盘的第二行，当前放置了皇后的个数是1，{i}，第一行皇后放置的位置i
// ...给我的感觉看来，回溯算法就像是穷举法
// 把每一条路都走一遍，当发现不对的时候再返回去走另外一条路
// 先做题感受吧
